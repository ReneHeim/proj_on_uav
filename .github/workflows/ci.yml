name: CI

on:
  push:
    branches: [main, dev]
  pull_request:
    branches: [main, dev]
  schedule:
    # Run dependency updates weekly (Mondays at 2 AM UTC)
    - cron: '0 2 * * 1'

env:
  PYTHON_VERSION: "3.12"
  MINIMUM_COVERAGE: 50

jobs:
  # =============================================================================
  # TESTING AND CODE QUALITY
  # =============================================================================
  test:
    name: Tests & Coverage
    runs-on: ubuntu-latest

    steps:
      # DOES: Downloads the repository code to the runner
      # DOESN'T: Clone submodules, apply patches, or verify code signatures
      # MAINTENANCE: Keep fetch-depth: 0 for tools that need git history
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Needed for coverage tools

      # DOES: Installs specified Python version from GitHub's tool cache
      # DOESN'T: Install multiple Python versions, validate Python environment
      # MAINTENANCE: Update to setup-python@v6 when available, monitor Python EOL dates
      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      # DOES: Caches pip packages based on requirements.txt hash for faster builds
      # DOESN'T: Cache virtual environments, handle poetry.lock, or clean stale cache
      # MAINTENANCE: Monitor cache hit rates, update cache keys if requirements structure changes
      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ env.PYTHON_VERSION }}-${{ hashFiles('**/requirements*.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-${{ env.PYTHON_VERSION }}-

      # DOES: Upgrades pip and installs project + test dependencies
      # DOESN'T: Create virtual environments, validate dependency compatibility, or handle conflicts
      # MAINTENANCE: Pin pytest versions if tests become flaky, review new pytest plugins quarterly
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov pytest-xdist pre-commit

      # DOES: Configures git hooks for local development consistency
      # DOESN'T: Actually run the hooks here (that's the next step)
      # MAINTENANCE: Ensure .pre-commit-config.yaml is updated regularly, review hook versions monthly
      - name: Set up pre-commit hooks
        run: pre-commit install

      # DOES: Runs all configured pre-commit hooks (linting, formatting, security checks)
      # DOESN'T: Auto-fix issues, ignore specific files, or handle hook failures gracefully
      # MAINTENANCE: Update hook versions in .pre-commit-config.yaml, add new hooks as needed
      - name: Run code quality checks
        run: |
          echo "Running pre-commit hooks..."
          pre-commit run --all-files || true

      # DOES: Runs unit tests with coverage reporting, parallel execution, and enforced minimum coverage
      # DOESN'T: Run integration tests, test against multiple Python versions, or generate HTML reports
      # MAINTENANCE: Adjust coverage threshold as codebase matures, review slow tests quarterly
      - name: Run unit tests with coverage
        run: |
          echo "Running unit tests..."
          PYTHONPATH=src python -m pytest tests/ \
            -v \
            --tb=short \
            --cov=src \
            --cov-report=xml \
            --cov-report=term-missing \
            --cov-fail-under=${{ env.MINIMUM_COVERAGE }} \
            -n auto

      # DOES: Runs end-to-end tests that verify complete user workflows
      # DOESN'T: Set up test databases, mock external services, or run performance tests
      # MAINTENANCE: Keep E2E tests lightweight, add browser testing if web app, review test data
      - name: Run end-to-end tests
        run: |
          echo "Running E2E tests..."
          PYTHONPATH=src python -m pytest tests/e2e/ -v --tb=short

      # DOES: Tests basic CLI functionality to ensure commands work
      # DOESN'T: Test all CLI options, validate output formats, or test error conditions
      # MAINTENANCE: Expand smoke tests as new CLI features are added, test on different OS
      - name: Run CLI smoke tests
        run: |
          echo "Running CLI smoke tests..."
          PYTHONPATH=src python -m pytest tests/test_smoke.py -v

      # DOES: Validates that Makefile targets execute successfully
      # DOESN'T: Test all Makefile targets, validate target outputs, or handle missing dependencies
      # MAINTENANCE: Keep Makefile targets simple, document required system dependencies
      - name: Test Makefile targets
        run: |
          echo "Testing Makefile targets..."
          make lint || true
          make format || true

      # DOES: Uploads coverage data to Codecov for tracking and PR comments
      # DOESN'T: Generate local HTML reports, handle multiple coverage formats, or validate upload
      # MAINTENANCE: Monitor Codecov integration, rotate tokens annually, review coverage trends
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          file: ./coverage.xml
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: true
          token: ${{ secrets.CODECOV_TOKEN }}

  # =============================================================================
  # SECURITY SCANNING
  # =============================================================================
  security:
    name: Security Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      # Modern approach: Use pip-audit instead of safety
      - name: Install modern security tools
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install bandit[toml]==1.7.9 pip-audit==2.6.2

      - name: Run Bandit code security scan
        run: |
          echo "Running Bandit security scan..."
          bandit -r src/ -f json -o bandit-report.json -ll || true
          bandit -r src/ -f txt -ll || true

      # pip-audit is more modern and actively maintained than safety
      - name: Run pip-audit dependency scan
        run: |
          echo "Running pip-audit dependency scan..."
          pip-audit --format=json --output=pip-audit-report.json || true
          pip-audit --format=text || true

      - name: Upload security reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-reports-${{ env.PYTHON_VERSION }}-${{ github.sha }}
          path: |
            bandit-report.json
            pip-audit-report.json
          retention-days: 30
  # =============================================================================
  # PACKAGE BUILDING
  # =============================================================================
  build:
    name: Build Package
    runs-on: ubuntu-latest
    needs: [test, security]

    steps:
      # DOES: Downloads source code for package building
      # DOESN'T: Include git tags, build from specific commits, or validate source integrity
      # MAINTENANCE: Ensure build reproducibility, consider using specific commit SHAs for releases
      - name: Checkout code
        uses: actions/checkout@v4

      # DOES: Sets up Python for package building tools
      # DOESN'T: Test builds on multiple Python versions or different architectures
      # MAINTENANCE: Consider matrix builds for multiple Python versions, add ARM64 support
      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      # DOES: Installs modern Python packaging tools with pinned versions
      # DOESN'T: Install platform-specific tools, C compilers, or signing tools
      # MAINTENANCE: Update build tools quarterly, monitor PEP updates for packaging standards
      - name: Install build dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build==1.0.3 twine==4.0.2

      # DOES: Creates both wheel and source distributions using modern build system
      # DOESN'T: Build for multiple platforms, sign packages, or optimize wheel contents
      # MAINTENANCE: Monitor build warnings, consider cibuildwheel for binary extensions
      - name: Build package
        run: |
          echo "Building package..."
          python -m build

      # DOES: Validates package metadata, structure, and PyPI compliance
      # DOESN'T: Test installation on clean systems, validate import paths, or check documentation
      # MAINTENANCE: Add more validation steps, test package installation in containers
      - name: Check package integrity
        run: |
          echo "Checking package integrity..."
          twine check dist/*

      # DOES: Installs built wheel to verify it works correctly
      # DOESN'T: Test in isolated environments, check all entry points, or validate dependencies
      # MAINTENANCE: Expand installation testing, add import tests for all modules
      - name: Test package installation
        run: |
          echo "Testing package installation..."
          pip install dist/*.whl
          python -c "import sys; print('Package installed successfully')"

      # DOES: Saves built packages as artifacts with 30-day retention
      # DOESN'T: Sign packages, generate checksums, or push to registries
      # MAINTENANCE: Consider artifact signing, automated publishing for releases
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-${{ env.PYTHON_VERSION }}-${{ github.sha }}
          path: dist/
          retention-days: 30

  # =============================================================================
  # DEPENDENCY MONITORING (Weekly)
  # =============================================================================
  dependency-check:
    name: Check Dependencies
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'

    steps:
      # DOES: Downloads current requirements files for analysis
      # DOESN'T: Check historical dependency changes or scan for malicious packages
      # MAINTENANCE: Consider dependency-track integration, monitor for typosquatting
      - name: Checkout code
        uses: actions/checkout@v4

      # DOES: Sets up Python for dependency analysis tools
      # DOESN'T: Test dependency compatibility across Python versions
      # MAINTENANCE: Run dependency checks on multiple Python versions
      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      # DOES: Installs dependency management tools with pinned version
      # DOESN'T: Install vulnerability scanners, license checkers, or supply chain tools
      # MAINTENANCE: Consider pip-audit, license-checker, and dependency-check tools
      - name: Install pip-tools
        run: |
          python -m pip install --upgrade pip
          pip install pip-tools==7.3.0

      # DOES: Identifies outdated packages and fails CI to get attention
      # DOESN'T: Distinguish between major/minor updates, check for breaking changes, or auto-update
      # MAINTENANCE: Add severity filtering, consider dependabot integration, review update policies
      - name: Check for outdated dependencies
        run: |
          echo "Checking for outdated dependencies..."
          pip install -r requirements.txt
          pip list --outdated --format=freeze > outdated.txt
          
          if [ -s outdated.txt ]; then
            echo "‚ö†Ô∏è Outdated dependencies found:"
            cat outdated.txt
            echo ""
            echo "Please consider updating these dependencies."
            exit 1
          else
            echo "‚úÖ All dependencies are up to date!"
          fi

      # DOES: Creates GitHub issue with outdated dependency details when check fails
      # DOESN'T: Update dependencies automatically, check for security advisories, or assign reviewers
      # MAINTENANCE: Add security context, auto-assign maintainers, link to dependency policies
      - name: Create dependency update issue
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const outdated = fs.readFileSync('outdated.txt', 'utf8');
            
            const issueBody = `
            ## üì¶ Outdated Dependencies Detected
            
            The weekly dependency check found outdated packages:
            
            \`\`\`
            ${outdated}
            \`\`\`
            
            ### Recommended Actions:
            1. Review the outdated packages
            2. Check for breaking changes in newer versions
            3. Update dependencies in \`requirements.txt\`
            4. Test thoroughly after updates
            
            **Scheduled check date:** ${new Date().toISOString().split('T')[0]}
            `;
            
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üîÑ Weekly Dependency Update - ${new Date().toISOString().split('T')[0]}`,
              body: issueBody,
              labels: ['dependencies', 'maintenance']
            });

  # =============================================================================
  # AUTO-FORMATTING (Internal PRs only for security)
  # =============================================================================
  auto-format:
    name: Auto-format Code
    runs-on: ubuntu-latest

    # SECURITY: Only run on internal PRs or direct pushes, never on external PRs
    if: |
      github.event_name == 'push' || 
      (github.event_name == 'pull_request' && 
       github.event.pull_request.head.repo.full_name == github.repository)

    permissions:
      contents: write
      pull-requests: write

    steps:
      # DOES: Downloads code with full history and pulls latest changes
      # DOESN'T: Handle complex merge conflicts automatically
      # MAINTENANCE: Monitor for merge conflicts, consider manual intervention alerts
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      # DOES: Syncs with remote branch to avoid divergence issues
      # DOESN'T: Handle merge conflicts, validate sync success
      # MAINTENANCE: Add conflict detection, consider rebase strategies
      - name: Sync with remote branch
        run: |
          git config --local user.name "github-actions[bot]"
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          
          # Get the current branch name
          CURRENT_BRANCH="${{ github.head_ref || github.ref_name }}"
          echo "Current branch: $CURRENT_BRANCH"
          
          # Fetch latest changes
          git fetch origin
          
          # Check if remote branch exists and sync
          if git ls-remote --heads origin "$CURRENT_BRANCH" | grep -q "$CURRENT_BRANCH"; then
            echo "Syncing with origin/$CURRENT_BRANCH..."
            git pull origin "$CURRENT_BRANCH" --rebase || {
              echo "‚ö†Ô∏è Rebase failed, trying merge..."
              git rebase --abort 2>/dev/null || true
              git pull origin "$CURRENT_BRANCH" --no-rebase
            }
          else
            echo "Remote branch $CURRENT_BRANCH doesn't exist, skipping sync"
          fi

      # DOES: Sets up Python environment for formatting tools
      # DOESN'T: Cache formatting tools, validate tool versions
      # MAINTENANCE: Consider caching pre-commit environments for speed
      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      # DOES: Installs pre-commit with pinned version for consistency
      # DOESN'T: Install additional formatters, validate installation
      # MAINTENANCE: Update pre-commit version quarterly, monitor for new tools
      - name: Install formatting tools
        run: |
          python -m pip install --upgrade pip
          pip install pre-commit==3.5.0

      # DOES: Runs all pre-commit hooks to auto-fix formatting issues
      # DOESN'T: Handle hook failures gracefully, validate fixes
      # MAINTENANCE: Review hook configurations, monitor formatting consistency
      - name: Run auto-formatting
        run: |
          echo "Running auto-formatting..."
          pre-commit run --all-files || echo "Some files were formatted"

      # DOES: Detects if any files were modified by formatting tools
      # DOESN'T: Validate that changes don't break functionality
      # MAINTENANCE: Consider adding syntax validation after formatting
      - name: Check for changes
        id: verify-changed-files
        run: |
          if [ -n "$(git status --porcelain)" ]; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "Files were auto-formatted"
            git status --porcelain
          else
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "No formatting changes needed"
          fi

      # DOES: Commits only existing file types, handles missing patterns gracefully
      # DOESN'T: Run tests after formatting, validate commit success
      # MAINTENANCE: Add post-formatting validation, monitor commit patterns
      - name: Commit formatting changes
        if: steps.verify-changed-files.outputs.changed == 'true'
        run: |
          echo "Committing formatting changes..."
          
          # Add files that exist, ignore missing patterns
          git add -A
          
          # Check if there are actually changes to commit
          if git diff --cached --quiet; then
            echo "No changes to commit after staging"
            exit 0
          fi
          
          # Commit changes
          git commit -m "style: auto-format code [skip ci]"
          
          # Push changes
          git push origin "${{ github.head_ref || github.ref_name }}"

  # =============================================================================
  # CI STATUS SUMMARY
  # =============================================================================
  ci-status:
    name: CI Status
    runs-on: ubuntu-latest
    needs: [test, security, build]
    if: always()

    steps:
      # DOES: Provides clear summary of all CI job results and fails if any critical job fails
      # DOESN'T: Send notifications, update status badges, or provide detailed failure analysis
      # MAINTENANCE: Add Slack/email notifications, update README badges, integrate with project dashboards
      - name: Check CI results
        run: |
          echo "üîç CI Pipeline Results:"
          echo "Tests: ${{ needs.test.result }}"
          echo "Security: ${{ needs.security.result }}"
          echo "Build: ${{ needs.build.result }}"
          
          if [[ "${{ needs.test.result }}" == "failure" || 
                "${{ needs.security.result }}" == "failure" || 
                "${{ needs.build.result }}" == "failure" ]]; then
            echo "‚ùå CI Pipeline Failed"
            exit 1
          else
            echo "‚úÖ CI Pipeline Passed"
          fi