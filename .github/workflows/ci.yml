name: CI

on:
  push:
    branches: [main, dev]
  pull_request:
    branches: [main, dev]
  schedule:
    # Run dependency updates weekly (Mondays at 2 AM UTC)
    - cron: '0 2 * * 1'

env:
  PYTHON_VERSION: "3.12"
  MINIMUM_COVERAGE: 50

jobs:
  # =============================================================================
  # TESTING AND CODE QUALITY
  # =============================================================================
  test:
    name: Tests & Coverage
    runs-on: ubuntu-latest

    steps:
      # DOES: Downloads the repository code to the runner
      # DOESN'T: Clone submodules, apply patches, or verify code signatures
      # MAINTENANCE: Keep fetch-depth: 0 for tools that need git history
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Needed for coverage tools

      # DOES: Installs specified Python version from GitHub's tool cache
      # DOESN'T: Install multiple Python versions, validate Python environment
      # MAINTENANCE: Update to setup-python@v6 when available, monitor Python EOL dates
      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      # DOES: Caches pip packages based on requirements.txt hash for faster builds
      # DOESN'T: Cache virtual environments, handle poetry.lock, or clean stale cache
      # MAINTENANCE: Monitor cache hit rates, update cache keys if requirements structure changes
      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ env.PYTHON_VERSION }}-${{ hashFiles('**/requirements*.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-${{ env.PYTHON_VERSION }}-

      # DOES: Upgrades pip and installs project + test dependencies
      # DOESN'T: Create virtual environments, validate dependency compatibility, or handle conflicts
      # MAINTENANCE: Pin pytest versions if tests become flaky, review new pytest plugins quarterly
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov pytest-xdist pre-commit

      # DOES: Configures git hooks for local development consistency
      # DOESN'T: Actually run the hooks here (that's the next step)
      # MAINTENANCE: Ensure .pre-commit-config.yaml is updated regularly, review hook versions monthly
      - name: Set up pre-commit hooks
        run: pre-commit install

      # DOES: Runs all configured pre-commit hooks (linting, formatting, security checks)
      # DOESN'T: Auto-fix issues, ignore specific files, or handle hook failures gracefully
      # MAINTENANCE: Update hook versions in .pre-commit-config.yaml, add new hooks as needed
      - name: Run code quality checks
        run: |
          echo "Running pre-commit hooks..."
          pre-commit run --all-files || true

      # DOES: Runs unit tests with coverage reporting, parallel execution, and enforced minimum coverage
      # DOESN'T: Run integration tests, test against multiple Python versions, or generate HTML reports
      # MAINTENANCE: Adjust coverage threshold as codebase matures, review slow tests quarterly
      - name: Run unit tests with coverage
        run: |
          echo "Running unit tests..."
          PYTHONPATH=src python -m pytest tests/ \
            -v \
            --tb=short \
            --cov=src \
            --cov-report=xml \
            --cov-report=term-missing \
            --cov-fail-under=${{ env.MINIMUM_COVERAGE }} \
            -n auto

      # DOES: Runs end-to-end tests that verify complete user workflows
      # DOESN'T: Set up test databases, mock external services, or run performance tests
      # MAINTENANCE: Keep E2E tests lightweight, add browser testing if web app, review test data
      - name: Run end-to-end tests
        run: |
          echo "Running E2E tests..."
          PYTHONPATH=src python -m pytest tests/e2e/ -v --tb=short

      # DOES: Tests basic CLI functionality to ensure commands work
      # DOESN'T: Test all CLI options, validate output formats, or test error conditions
      # MAINTENANCE: Expand smoke tests as new CLI features are added, test on different OS
      - name: Run CLI smoke tests
        run: |
          echo "Running CLI smoke tests..."
          PYTHONPATH=src python -m pytest tests/test_smoke.py -v

      # DOES: Validates that Makefile targets execute successfully
      # DOESN'T: Test all Makefile targets, validate target outputs, or handle missing dependencies
      # MAINTENANCE: Keep Makefile targets simple, document required system dependencies
      - name: Test Makefile targets
        run: |
          echo "Testing Makefile targets..."
          make lint || true
          make format || true

      # DOES: Uploads coverage data to Codecov for tracking and PR comments
      # DOESN'T: Generate local HTML reports, handle multiple coverage formats, or validate upload
      # MAINTENANCE: Monitor Codecov integration, rotate tokens annually, review coverage trends
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          file: ./coverage.xml
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false
          token: ${{ secrets.CODECOV_TOKEN }}

  # =============================================================================
  # SECURITY SCANNING
  # =============================================================================
  security:
    name: Security Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      # Modern approach: Use pip-audit instead of safety
      - name: Install modern security tools
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install bandit[toml]==1.7.9 pip-audit==2.6.2

      - name: Run Bandit code security scan
        run: |
          echo "Running Bandit security scan..."
          bandit -r src/ -f json -o bandit-report.json -ll || true
          bandit -r src/ -f txt -ll || true

      # pip-audit is more modern and actively maintained than safety
      - name: Run pip-audit dependency scan
        run: |
          echo "Running pip-audit dependency scan..."
          pip-audit --format=json --output=pip-audit-report.json || true
          pip-audit --format=text || true

      - name: Upload security reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-reports-${{ env.PYTHON_VERSION }}-${{ github.sha }}
          path: |
            bandit-report.json
            pip-audit-report.json
          retention-days: 30
  # =============================================================================
  # PACKAGE BUILDING
  # =============================================================================
  build:
    name: Build Package
    runs-on: ubuntu-latest
    needs: [test, security]

    steps:
      # DOES: Downloads source code for package building
      # DOESN'T: Include git tags, build from specific commits, or validate source integrity
      # MAINTENANCE: Ensure build reproducibility, consider using specific commit SHAs for releases
      - name: Checkout code
        uses: actions/checkout@v4

      # DOES: Sets up Python for package building tools
      # DOESN'T: Test builds on multiple Python versions or different architectures
      # MAINTENANCE: Consider matrix builds for multiple Python versions, add ARM64 support
      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      # DOES: Installs modern Python packaging tools with compatible versions
      # DOESN'T: Install platform-specific tools, C compilers, or signing tools
      # MAINTENANCE: Update build tools quarterly, monitor PEP updates for packaging standards
      - name: Install build dependencies
        run: |
          python -m pip install --upgrade pip
          # Use compatible versions that work together
          pip install build==1.0.3 twine==4.0.2 setuptools>=65.0

      # DOES: Creates both wheel and source distributions using modern build system
      # DOESN'T: Build for multiple platforms, sign packages, or optimize wheel contents
      # MAINTENANCE: Monitor build warnings, consider cibuildwheel for binary extensions
      - name: Build package
        run: |
          echo "Building package..."
          python -m build --wheel --sdist

      # DOES: Validates package metadata, structure, and PyPI compliance with error handling
      # DOESN'T: Test installation on clean systems, validate import paths, or check documentation
      # MAINTENANCE: Add more validation steps, test package installation in containers
      - name: Check package integrity
        run: |
          echo "Checking package integrity..."
          
          # Check if dist directory exists and has files
          if [ ! -d "dist" ] || [ -z "$(ls -A dist)" ]; then
            echo "Error: No distribution files found"
            exit 1
          fi
          
          echo "Distribution files found:"
          ls -la dist/
          
          # Try twine check with fallback
          if ! twine check dist/*; then
            echo "Warning: twine check failed, performing basic validation..."
            
            # Basic file validation
            for file in dist/*; do
              if [[ $file == *.whl ]]; then
                echo "Checking wheel file: $file"
                python -m zipfile -l "$file" > /dev/null || {
                  echo "Error: Invalid wheel file $file"
                  exit 1
                }
              elif [[ $file == *.tar.gz ]]; then
                echo "Checking source distribution: $file"
                tar -tzf "$file" > /dev/null || {
                  echo "Error: Invalid source distribution $file"
                  exit 1
                }
              fi
            done
            echo "Basic package validation completed"
          else
            echo "Package integrity check passed"
          fi

      # DOES: Installs built wheel to verify it works correctly with error handling
      # DOESN'T: Test in isolated environments, check all entry points, or validate dependencies
      # MAINTENANCE: Expand installation testing, add import tests for all modules
      - name: Test package installation
        run: |
          echo "Testing package installation..."
          
          # Find the wheel file
          WHEEL_FILE=$(find dist -name "*.whl" | head -1)
          
          if [ -z "$WHEEL_FILE" ]; then
            echo "Error: No wheel file found for testing"
            exit 1
          fi
          
          echo "Installing wheel: $WHEEL_FILE"
          pip install "$WHEEL_FILE"
          
          # Test basic import (adjust package name as needed)
          python -c "
          import sys
          print('Package installed successfully')
          print('Python version:', sys.version)
          
          # Try to import your main package (replace 'your_package' with actual name)
          try:
              # Add your actual package import here
              # import your_package
              print('Package import test: SKIPPED (no package specified)')
          except ImportError as e:
              print('Package import test: FAILED -', e)
              # Uncomment the next line if you want import failures to fail the build
              # sys.exit(1)
          except Exception as e:
              print('Package import test: ERROR -', e)
              # Uncomment the next line if you want other errors to fail the build
              # sys.exit(1)
          "

      # DOES: Saves built packages as artifacts with 30-day retention
      # DOESN'T: Sign packages, generate checksums, or push to registries
      # MAINTENANCE: Consider artifact signing, automated publishing for releases
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-${{ env.PYTHON_VERSION }}-${{ github.sha }}
          path: dist/
          retention-days: 30

      # DOES: Provides summary of build results and file information
      # DOESN'T: Calculate checksums, validate file sizes, or check for completeness
      # MAINTENANCE: Add checksum generation, size validation, comprehensive build reports
      - name: Build summary
        if: always()
        run: |
          echo "Build Summary"
          echo "============="
          
          if [ -d "dist" ] && [ -n "$(ls -A dist)" ]; then
            echo "Build Status: SUCCESS"
            echo "Files created:"
            for file in dist/*; do
              if [ -f "$file" ]; then
                SIZE=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null || echo "unknown")
                echo "  - $(basename "$file") (${SIZE} bytes)"
              fi
            done
          else
            echo "Build Status: FAILED - No distribution files created"
          fi
          
          echo "Build completed at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"

  # =============================================================================
  # DEPENDENCY MONITORING (Weekly)
  # =============================================================================
  dependency-check:
    name: Check Dependencies
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'

    steps:
      # DOES: Downloads current requirements files for analysis
      # DOESN'T: Check historical dependency changes or scan for malicious packages
      # MAINTENANCE: Consider dependency-track integration, monitor for typosquatting
      - name: Checkout code
        uses: actions/checkout@v4

      # DOES: Sets up Python for dependency analysis tools
      # DOESN'T: Test dependency compatibility across Python versions
      # MAINTENANCE: Run dependency checks on multiple Python versions
      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      # DOES: Installs dependency management tools with pinned version
      # DOESN'T: Install vulnerability scanners, license checkers, or supply chain tools
      # MAINTENANCE: Consider pip-audit, license-checker, and dependency-check tools
      - name: Install pip-tools
        run: |
          python -m pip install --upgrade pip
          pip install pip-tools==7.3.0

      # DOES: Identifies outdated packages and fails CI to get attention
      # DOESN'T: Distinguish between major/minor updates, check for breaking changes, or auto-update
      # MAINTENANCE: Add severity filtering, consider dependabot integration, review update policies
      - name: Check for outdated dependencies
        run: |
          echo "Checking for outdated dependencies..."
          pip install -r requirements.txt
          pip list --outdated --format=freeze > outdated.txt
          
          if [ -s outdated.txt ]; then
            echo "‚ö†Ô∏è Outdated dependencies found:"
            cat outdated.txt
            echo ""
            echo "Please consider updating these dependencies."
            exit 1
          else
            echo "‚úÖ All dependencies are up to date!"
          fi

      # DOES: Creates GitHub issue with outdated dependency details when check fails
      # DOESN'T: Update dependencies automatically, check for security advisories, or assign reviewers
      # MAINTENANCE: Add security context, auto-assign maintainers, link to dependency policies
      - name: Create dependency update issue
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const outdated = fs.readFileSync('outdated.txt', 'utf8');
            
            const issueBody = `
            ## üì¶ Outdated Dependencies Detected
            
            The weekly dependency check found outdated packages:
            
            \`\`\`
            ${outdated}
            \`\`\`
            
            ### Recommended Actions:
            1. Review the outdated packages
            2. Check for breaking changes in newer versions
            3. Update dependencies in \`requirements.txt\`
            4. Test thoroughly after updates
            
            **Scheduled check date:** ${new Date().toISOString().split('T')[0]}
            `;
            
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üîÑ Weekly Dependency Update - ${new Date().toISOString().split('T')[0]}`,
              body: issueBody,
              labels: ['dependencies', 'maintenance']
            });
  # =============================================================================
  # AUTO-FORMATTING (Internal PRs only for security)
  # =============================================================================
  auto-format:
    name: Auto-format Code
    runs-on: ubuntu-latest

    if: |
      github.event_name == 'push' || 
      (github.event_name == 'pull_request' && 
       github.event.pull_request.head.repo.full_name == github.repository)

    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install formatting tools
        run: |
          python -m pip install --upgrade pip
          pip install pre-commit==3.5.0

      # DOES: Runs existing pre-commit configuration while excluding workflow files
      # DOESN'T: Override your carefully configured pre-commit settings
      # MAINTENANCE: Update versions in your .pre-commit-config.yaml file, not in the workflow
      - name: Run auto-formatting
        run: |
          echo "Running auto-formatting with project pre-commit config..."
          pre-commit run --all-files || echo "Some files were formatted"

      - name: Check for changes (excluding workflows)
        id: verify-changed-files
        run: |
          # Check for changes but exclude workflow files
          CHANGED_FILES=$(git status --porcelain | grep -v "^.* \.github/workflows/" || true)
          
          if [ -n "$CHANGED_FILES" ]; then
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "Non-workflow files were auto-formatted:"
            echo "$CHANGED_FILES"
          else
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "No formatting changes needed (excluding workflows)"
          fi

      - name: Commit formatting changes (excluding workflows)
        if: steps.verify-changed-files.outputs.changed == 'true'
        run: |
          echo "Committing non-workflow formatting changes..."
          
          git config --local user.name "github-actions[bot]"
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          
          # Add only non-workflow files
          git add .
          git reset -- .github/workflows/
          
          # Check if there are still changes to commit
          if git diff --cached --quiet; then
            echo "No changes to commit after excluding workflows"
            exit 0
          fi
          
          git commit -m "style: auto-format code (excluding workflows) [skip ci]"
          
          BRANCH_NAME="${{ github.head_ref || github.ref_name }}"
          
          # Simple push with retry
          for i in {1..3}; do
            echo "Attempt $i to push changes..."
            if git push origin "$BRANCH_NAME"; then
              echo "Successfully pushed formatting changes!"
              break
            elif [ $i -eq 3 ]; then
              echo "Failed to push after 3 attempts"
              exit 1
            else
              echo "Push failed, syncing and retrying..."
              git fetch origin "$BRANCH_NAME"
              git rebase "origin/$BRANCH_NAME" || {
                git rebase --abort
                git pull origin "$BRANCH_NAME" --no-rebase
              }
            fi
          done
  # =============================================================================
  # CI STATUS SUMMARY
  # =============================================================================
  ci-status:
    name: CI Status
    runs-on: ubuntu-latest
    needs: [test, security, build]
    if: always()

    steps:
      # DOES: Provides clear summary of all CI job results and fails if any critical job fails
      # DOESN'T: Send notifications, update status badges, or provide detailed failure analysis
      # MAINTENANCE: Add Slack/email notifications, update README badges, integrate with project dashboards
      - name: Check CI results
        run: |
          echo "üîç CI Pipeline Results:"
          echo "Tests: ${{ needs.test.result }}"
          echo "Security: ${{ needs.security.result }}"
          echo "Build: ${{ needs.build.result }}"
          
          if [[ "${{ needs.test.result }}" == "failure" || 
                "${{ needs.security.result }}" == "failure" || 
                "${{ needs.build.result }}" == "failure" ]]; then
            echo "‚ùå CI Pipeline Failed"
            exit 1
          else
            echo "‚úÖ CI Pipeline Passed"
          fi